{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TypeID Python","text":""},{"location":"#a-python-implementation-of-typeids-using-python","title":"A Python implementation of TypeIDs using Python","text":"<p>TypeIDs are a modern, type-safe, globally unique identifier based on the upcoming UUIDv7 standard. They provide a ton of nice properties that make them a great choice as the primary identifiers for your data in a database, APIs, and distributed systems. Read more about TypeIDs in their spec.</p> <p>This particular implementation provides an pip package that can be used by any Python project.</p>"},{"location":"#installation","title":"Installation","text":"<ul> <li> <p>Pip:</p> <pre><code>pip install typeid-python\n</code></pre> </li> <li> <p>Uv:</p> <pre><code>uv add typeid-python\n</code></pre> </li> <li> <p>Poetry:</p> <pre><code>poetry add typeid-python\n</code></pre> </li> </ul>"},{"location":"#optional-dependencies","title":"Optional dependencies","text":"<p>TypeID supports schema-based ID explanations using JSON (always available) and YAML (optional).</p> <p>To enable YAML support:</p> <pre><code>pip install typeid-python[yaml]\n</code></pre> <p>If the extra is not installed, JSON schemas will still work.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#basic","title":"Basic","text":"<ul> <li> <p>Create TypeID Instance:</p> <pre><code>from typeid import TypeID\n\n# Default TypeID (no prefix)\ntypeid = TypeID()\n\nassert typeid.prefix == \"\"\nassert isinstance(typeid.suffix, str)\nassert len(typeid.suffix) &gt; 0  # encoded UUIDv7\n\n# TypeID with prefix\ntypeid = TypeID(prefix=\"user\")\n\nassert typeid.prefix == \"user\"\nassert str(typeid).startswith(\"user_\")\n</code></pre> </li> <li> <p>Create TypeID from string:</p> <pre><code>from typeid import TypeID\n\nvalue = \"user_01h45ytscbebyvny4gc8cr8ma2\"\ntypeid = TypeID.from_string(value)\n\nassert str(typeid) == value\nassert typeid.prefix == \"user\"\n</code></pre> </li> <li> <p>Create TypeID from uuid7:</p> <pre><code>from typeid import TypeID\nfrom uuid6 import uuid7\n\nuuid = uuid7()\nprefix = \"user\"\n\ntypeid = TypeID.from_uuid(prefix=prefix, suffix=uuid)\n\nassert typeid.prefix == prefix\nassert str(typeid).startswith(f\"{prefix}_\")\n</code></pre> </li> <li> <p>Use pre-defined prefix:</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Literal\nfrom typeid import TypeID, typeid_factory\n\nUserID = TypeID[Literal[\"user\"]]\ngen_user_id = typeid_factory(\"user\")\n\n\n@dataclass\nclass UserDTO:\n    user_id: UserID = field(default_factory=gen_user_id)\n    full_name: str = \"A J\"\n    age: int = 18\n\n\nuser = UserDTO()\n\nassert str(user.user_id).startswith(\"user_\")\n</code></pre> </li> </ul>"},{"location":"#cli-tool","title":"CLI-tool","text":"<ul> <li> <p>Install dependencies:</p> <pre><code>pip install typeid-python[cli]\n</code></pre> </li> <li> <p>To generate a new TypeID, run:</p> <pre><code>$ typeid new -p prefix\nprefix_01h2xcejqtf2nbrexx3vqjhp41\n</code></pre> </li> <li> <p>To decode an existing TypeID into a UUID run:</p> <pre><code>$ typeid decode prefix_01h2xcejqtf2nbrexx3vqjhp41\ntype: prefix\nuuid: 0188bac7-4afa-78aa-bc3b-bd1eef28d881\n</code></pre> </li> <li> <p>And to encode an existing UUID into a TypeID run:</p> <pre><code>$ typeid encode 0188bac7-4afa-78aa-bc3b-bd1eef28d881 --prefix prefix\nprefix_01h2xcejqtf2nbrexx3vqjhp41\n</code></pre> </li> </ul>"},{"location":"#new-typeid-explain-what-is-this-id","title":"\u2728 NEW: <code>typeid explain</code> \u2014 \u201cWhat is this ID?\u201d","text":"<p>TypeID can now explain a TypeID in a human-readable way.</p> <p>This is useful when:</p> <ul> <li>debugging logs</li> <li>inspecting database records</li> <li>reviewing production incidents</li> <li>understanding IDs shared via Slack, tickets, or dashboards</li> </ul>"},{"location":"#basic-usage-no-schema-required","title":"Basic usage (no schema required)","text":"<pre><code>$ typeid explain user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>Example output:</p> <pre><code>id: user_01h45ytscbebyvny4gc8cr8ma2\nvalid: true\n\nparsed:\n  prefix: user\n  suffix: 01h45ytscbebyvny4gc8cr8ma2\n  uuid: 01890bf0-846f-7762-8605-5a3abb40e0e5\n  created_at: 2025-03-12T10:41:23Z\n  sortable: true\n\nschema:\n  found: false\n</code></pre> <p>Even without configuration, <code>typeid explain</code> can:</p> <ul> <li>validate the ID</li> <li>extract the UUID</li> <li>derive creation time (UUIDv7)</li> <li>determine sortability</li> </ul>"},{"location":"#schema-based-explanations","title":"Schema-based explanations","text":"<p>To make explanations richer, you can define a TypeID schema describing what each prefix represents.</p>"},{"location":"#example-schema-typeidschemajson","title":"Example schema (<code>typeid.schema.json</code>)","text":"<pre><code>{\n  \"schema_version\": 1,\n  \"types\": {\n    \"user\": {\n      \"name\": \"User\",\n      \"description\": \"End-user account\",\n      \"owner_team\": \"identity-platform\",\n      \"pii\": true,\n      \"retention\": \"7y\",\n      \"links\": {\n        \"logs\": \"https://logs.company/search?q={id}\",\n        \"trace\": \"https://traces.company/?id={id}\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"#explain-using-schema","title":"Explain using schema","text":"<pre><code>$ typeid explain user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>Output (excerpt):</p> <pre><code>schema:\n  found: true\n  name: User\n  owner_team: identity-platform\n  pii: true\n  retention: 7y\n\nlinks:\n  logs: https://logs.company/search?q=user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre>"},{"location":"#schema-discovery-rules","title":"Schema discovery rules","text":"<p>If <code>--schema</code> is not provided, TypeID looks for a schema in the following order:</p> <ol> <li>Environment variable:</li> </ol> <p><pre><code>TYPEID_SCHEMA=/path/to/schema.json\n</code></pre> 2. Current directory:</p> <ul> <li><code>typeid.schema.json</code></li> <li><code>typeid.schema.yaml</code></li> <li> <p>User config directory:</p> </li> <li> <p><code>~/.config/typeid/schema.json</code></p> </li> <li><code>~/.config/typeid/schema.yaml</code></li> </ul> <p>If no schema is found, the command still works with derived information only.</p>"},{"location":"#yaml-schemas-optional","title":"YAML schemas (optional)","text":"<p>YAML schemas are supported if the optional dependency is installed:</p> <pre><code>pip install typeid-python[yaml]\n</code></pre> <p>Example (<code>typeid.schema.yaml</code>):</p> <pre><code>schema_version: 1\ntypes:\n  user:\n    name: User\n    owner_team: identity-platform\n    links:\n      logs: \"https://logs.company/search?q={id}\"\n</code></pre>"},{"location":"#json-output-machine-readable","title":"JSON output (machine-readable)","text":"<pre><code>$ typeid explain user_01h45ytscbebyvny4gc8cr8ma2 --json\n</code></pre> <p>Useful for:</p> <ul> <li>scripts</li> <li>CI pipelines</li> <li>IDE integrations</li> </ul>"},{"location":"#design-principles","title":"Design principles","text":"<ul> <li>Non-breaking: existing APIs and CLI commands remain unchanged</li> <li>Schema-optional: works fully offline</li> <li>Read-only: no side effects or external mutations</li> <li>Declarative: meaning is defined by users, not inferred by the tool</li> </ul> <p>You can think of <code>typeid explain</code> as:</p> <p>OpenAPI \u2014 but for identifiers instead of HTTP endpoints</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"concepts/","title":"Concepts","text":"<p>TypeID exists because identifiers are used for much more than uniqueness.</p> <p>They appear in logs, URLs, dashboards, tickets, alerts, database rows, and Slack messages. Yet most identifiers\u2014especially UUIDs\u2014are opaque. They carry no meaning, no context, and no affordances for inspection.</p> <p>TypeID is an attempt to fix that, without breaking the properties that make UUIDs useful.</p>"},{"location":"concepts/#typeid-as-an-identifier","title":"TypeID as an identifier","text":"<p>A TypeID is a string identifier composed of two independent parts:</p> <pre><code>&lt;prefix&gt;_&lt;suffix&gt;\n</code></pre> <p>For example:</p> <pre><code>user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>The suffix is the identity. It is globally unique and backed by a UUID. The prefix is context. It tells a human (and tooling) what kind of thing the identifier refers to.</p> <p>Crucially, the prefix does not participate in uniqueness. Two TypeIDs with different prefixes but the same suffix represent the same underlying UUID. The prefix is a semantic layer, not a storage primitive.</p> <p>This separation is intentional. It allows TypeID to add meaning without interfering with existing UUID-based systems.</p>"},{"location":"concepts/#uuid-compatibility-by-design","title":"UUID compatibility by design","text":"<p>TypeID is not a replacement for UUIDs. It is a layer on top of them.</p> <p>Every TypeID corresponds to exactly one UUID, and that UUID can always be extracted or reconstructed. This makes it possible to:</p> <ul> <li>store native UUIDs in databases</li> <li>use existing UUID indexes and constraints</li> <li>introduce TypeID without schema migrations</li> <li>roll back or interoperate with systems that know nothing about TypeID</li> </ul> <p>The recommended pattern is simple: store UUIDs, expose TypeIDs.</p> <p>TypeID lives at the boundaries of your system\u2014APIs, logs, tooling\u2014not at the lowest storage level.</p>"},{"location":"concepts/#sortability-and-time","title":"Sortability and time","text":"<p>The suffix used by TypeID is time-sortable. When two TypeIDs are compared lexicographically, the one created earlier sorts before the one created later.</p> <p>This property is not about business semantics; it is about ergonomics.</p> <p>Sortable identifiers make logs readable, pagination predictable, and debugging less frustrating. When you scan a list of IDs, you can usually infer their relative age without additional metadata.</p> <p>There are important limits to this property. Ordering reflects generation time, not transaction time or business events. Clock skew and distributed systems still exist. TypeID does not attempt to impose global ordering or causality.</p> <p>Sortability is a convenience, not a guarantee.</p>"},{"location":"concepts/#explainability","title":"Explainability","text":"<p>Once an identifier carries structure, it becomes possible to inspect it.</p> <p>TypeID can be explained: given a string, the system can determine whether it is a valid TypeID, extract its UUID, derive its creation time, and report these facts in a structured way.</p> <p>This is useful in places where identifiers normally appear as dead text:</p> <ul> <li>logs</li> <li>error messages</li> <li>database dumps</li> <li>incident reports</li> <li>CI output</li> </ul> <p>Explainability is designed to be safe. Invalid identifiers do not crash the system. Unknown prefixes are accepted. Each identifier is handled independently, which makes batch processing robust.</p>"},{"location":"concepts/#schemas-as-optional-meaning","title":"Schemas as optional meaning","text":"<p>Derived facts are always available, but they are not always enough. In real systems, prefixes often correspond to domain concepts: users, orders, events, aggregates.</p> <p>Schemas allow you to describe that meaning explicitly.</p> <p>A schema can say that a <code>user</code> ID represents an end-user account, that it contains PII, that it is owned by a particular team, or that related logs and dashboards can be found at specific URLs.</p> <p>Schemas are optional and additive. If a schema is missing, outdated, or invalid, TypeID still works. The identifier does not become invalid because metadata could not be loaded.</p> <p>This separation keeps the core identifier system stable while allowing richer interpretation where it is useful.</p>"},{"location":"concepts/#unknown-and-invalid-identifiers","title":"Unknown and invalid identifiers","text":"<p>TypeID makes a clear distinction between identifiers that are invalid and those that are merely unknown.</p> <p>An invalid identifier is structurally wrong: it cannot be parsed or decoded. An unknown identifier is structurally valid, but its prefix is not recognized by any schema.</p> <p>Unknown identifiers are first-class citizens. They allow systems to evolve independently and avoid tight coupling between producers and consumers of IDs.</p> <p>This distinction is essential for forward compatibility and safe tooling.</p>"},{"location":"concepts/#a-note-on-safety","title":"A note on safety","text":"<p>TypeID is deliberately conservative.</p> <p>It does not infer meaning. It does not mutate state. It does not enforce authorization. It does not treat identifiers as secrets.</p> <p>Its goal is to make identifiers more understandable.</p>"},{"location":"concepts/#closing-thoughts","title":"Closing thoughts","text":"<p>TypeID treats identifiers as part of the system\u2019s interface, not as incidental implementation details.</p> <p>By combining UUID compatibility, time-based sortability, and structured explainability, it aims to make everyday engineering tasks\u2014debugging, inspection, reasoning\u2014slightly less painful.</p> <p>Identifiers should not be mysterious. They should be inspectable, understandable, and boring in the best possible way.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>This document describes how to contribute to typeid-python.</p> <p>Thank you for taking the time to contribute \u2764\ufe0f</p>"},{"location":"contributing/#requirements","title":"Requirements","text":"<ul> <li>Linux or macOS (the development workflow is primarily tested on Unix-like systems)</li> <li>A supported Python version (e.g. Python 3.10+; latest tested: Python 3.14)</li> <li><code>uv</code> \u2013 fast Python package manager and environment tool</li> </ul>"},{"location":"contributing/#installation","title":"Installation","text":""},{"location":"contributing/#1-fork-clone","title":"1. Fork &amp; clone","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:</li> </ol> <pre><code>git clone https://github.com/akhundMurad/typeid-python.git\ncd typeid-python\n</code></pre>"},{"location":"contributing/#2-install-uv","title":"2. Install <code>uv</code>","text":"<pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Verify installation:</p> <pre><code>uv --version\n</code></pre>"},{"location":"contributing/#3-set-up-the-development-environment","title":"3. Set up the development environment","text":"<p>Create and sync the virtual environment (including dev dependencies):</p> <pre><code>uv sync --all-groups\n</code></pre> <p>This will:</p> <ul> <li>create a local <code>.venv/</code></li> <li>install dependencies according to <code>uv.lock</code></li> <li>keep the environment reproducible</li> </ul>"},{"location":"contributing/#running-tests","title":"Running tests","text":"<pre><code>make test\n</code></pre> <p>or directly:</p> <pre><code>uv run pytest -v\n</code></pre>"},{"location":"contributing/#formatters-linters","title":"Formatters &amp; linters","text":"<p>We use the following tools:</p> <ul> <li>ruff \u2013 linting &amp; import sorting</li> <li>black \u2013 code formatting</li> <li>mypy \u2013 static type checking</li> </ul> <p>Run all linters:</p> <pre><code>make check-linting\n</code></pre> <p>Auto-fix formatting issues where possible:</p> <pre><code>make fix-linting\n</code></pre>"},{"location":"contributing/#building-the-package","title":"Building the package","text":"<p>Build wheel and source distribution:</p> <pre><code>make build\n</code></pre> <p>This uses <code>uv build</code> under the hood.</p>"},{"location":"contributing/#testing-extras-cli","title":"Testing extras (CLI)","text":"<p>To test the CLI extra locally:</p> <pre><code>uv sync --all-groups --extra cli\nuv run typeid new -p test\n</code></pre>"},{"location":"contributing/#lockfile-discipline","title":"Lockfile discipline","text":"<ul> <li><code>uv.lock</code> must be committed</li> <li>Always run dependency changes via <code>uv add</code> / <code>uv remove</code></li> <li>CI uses <code>uv sync --locked</code>, so lockfile drift will fail builds</li> </ul>"},{"location":"contributing/#how-to-name-branches","title":"How to name branches","text":"<p>Branch names are flexible, as long as they are respectful and descriptive.</p> <p>Recommended patterns:</p> <ul> <li><code>fix/core/32</code></li> <li><code>feature/cli-support</code></li> <li><code>docs/readme-update</code></li> <li><code>chore/ci-cleanup</code></li> </ul> <p>Referencing an issue number in the branch name is encouraged but not required.</p>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Create a feature branch</li> <li>Make sure tests and linters pass</li> <li>Commit with a clear message</li> <li>Open a pull request against <code>main</code></li> <li>Describe what changed and why</li> </ol> <p>Happy hacking \ud83d\ude80 If something is unclear, feel free to open an issue or discussion.</p>"},{"location":"explain/","title":"Explain","text":"<p>The <code>explain</code> feature exists because identifiers rarely live in isolation.</p> <p>They appear in logs, stack traces, database rows, monitoring dashboards, tickets, and CI output. When something goes wrong, engineers are often faced with a string that looks like an identifier and the implicit question:</p> <p>\u201cWhat is this ID?\u201d</p> <p>In most systems, that question cannot be answered without code, database access, or tribal knowledge. <code>typeid explain</code> is an attempt to make identifiers themselves carry enough structure to answer that question directly.</p>"},{"location":"explain/#what-explain-means","title":"What \u201cexplain\u201d means","text":"<p>To explain a TypeID means to inspect it and produce structured information about it.</p> <p>This includes: - whether the identifier is structurally valid - what prefix it uses - which UUID it represents - when it was created - whether it is sortable</p> <p>These facts are derived purely from the identifier itself. They require no configuration, no network access, and no external state.</p> <p>This is the baseline: explanation always works, even offline.</p>"},{"location":"explain/#derived-facts","title":"Derived facts","text":"<p>Every explanation starts with derived facts.</p> <p>Given a string, the system attempts to parse it as a TypeID. If parsing succeeds, the result includes: - the parsed prefix (or absence of one) - the underlying UUID - the approximate creation time - sortability guarantees</p> <p>If parsing fails, the explanation still succeeds \u2014 it simply reports that the identifier is invalid and why.</p> <p>This distinction is important. <code>explain</code> is not a validator that throws errors; it is an inspection tool that always returns an answer.</p>"},{"location":"explain/#invalid-vs-unknown","title":"Invalid vs unknown","text":"<p>An invalid identifier is one that cannot be parsed at all. Its structure is wrong, its encoding is broken, or it does not conform to the TypeID format.</p> <p>An unknown identifier, on the other hand, may be perfectly valid but use a prefix that the system does not recognize.</p> <p><code>explain</code> treats these cases very differently.</p> <p>Invalid identifiers are reported as invalid. Unknown identifiers are reported as valid, but unrecognized.</p> <p>This distinction allows systems to evolve independently. Producers of IDs can introduce new prefixes without breaking consumers, and tooling can remain forward-compatible.</p>"},{"location":"explain/#schemas-as-optional-meaning","title":"Schemas as optional meaning","text":"<p>Derived facts answer questions about structure and origin, but they do not answer questions about semantics.</p> <p>What does a <code>user</code> ID represent? Does it contain PII? Which team owns it? Where should an engineer look next?</p> <p>Schemas exist to answer these questions.</p> <pre><code>schema_version: 1\ntypes:\n  user:\n    name: User\n    description: End-user account\n    owner_team: identity-platform\n    pii: true\n    retention: 7y\n    services: [user-service, auth-service]\n    storage:\n      primary:\n        kind: postgres\n        table: users\n        shard_by: tenant_id\n    events: [user.created, user.updated, user.deleted]\n    policies:\n      delete:\n        allowed: false\n        reason: GDPR retention policy\n    links:\n      docs: \"https://docs.company/entities/user\"\n      logs: \"https://logs.company/search?q={id}\"\n      trace: \"https://traces.company/?q={id}\"\n      admin: \"https://admin.company/users/{id}\"\n</code></pre> <p>A schema is a declarative description of what a prefix means. It can attach human-readable descriptions, ownership information, retention rules, links to logs or dashboards, and other metadata that helps people reason about identifiers in context.</p> <p>Schemas are explicitly optional. They are not required for explanation, and they never affect structural validity.</p> <p>If a schema is present and valid, <code>explain</code> enriches the output. If a schema is missing, outdated, or invalid, explanation still works using derived facts only.</p>"},{"location":"explain/#schema-discovery","title":"Schema discovery","text":"<p>To make schemas practical, <code>explain</code> supports discovery.</p> <p>Rather than requiring every invocation to specify a schema path explicitly, the system looks for schemas in well-defined locations, such as environment variables, the current working directory, or a user-level configuration directory.</p> <p>This allows schemas to be shared across tools, CI jobs, and developer machines without tight coupling.</p> <p>Discovery failure is not an error. It is simply reported as \u201cschema not found\u201d.</p>"},{"location":"explain/#links-and-affordances","title":"Links and affordances","text":"<p>One of the most practical uses of schemas is attaching links.</p> <p>A schema can define URL templates for logs, traces, admin tools, dashboards, or documentation. During explanation, these templates are expanded using the identifier being explained.</p> <p>This turns an identifier into a navigational object: from an ID, you can jump directly to relevant systems without knowing how URLs are constructed.</p> <p>This is especially useful during incident response and debugging, where speed and clarity matter.</p>"},{"location":"explain/#batch-explanation","title":"Batch explanation","text":"<p>Explanation is designed to scale beyond single identifiers.</p> <p>Batch explanation allows many IDs to be processed independently. One invalid identifier does not affect others. Partial results are always produced.</p> <p>This makes <code>explain</code> suitable for: - CI checks - offline analysis - reporting - log and data pipeline inspection</p> <p>Machine-readable output formats make it easy to integrate with other tooling.</p>"},{"location":"explain/#safety-and-non-goals","title":"Safety and non-goals","text":"<p>The <code>explain</code> feature is intentionally conservative.</p> <p>It does not: - mutate data - enforce policy - make authorization decisions - infer meaning beyond what is explicitly declared</p> <p>Schemas describe intent; they do not impose it.</p> <p>Identifiers remain identifiers. <code>explain</code> helps humans and tools understand them, nothing more.</p>"},{"location":"explain/#mental-model","title":"Mental model","text":"<p>A useful way to think about <code>typeid explain</code> is:</p> <p>OpenAPI, but for identifiers instead of HTTP endpoints</p> <p>It provides a shared, inspectable contract for something that is otherwise opaque and informal.</p>"},{"location":"explain/#closing","title":"Closing","text":"<p>Identifiers are part of a system\u2019s interface, whether we acknowledge it or not.</p> <p>By making identifiers inspectable and explainable, TypeID aims to reduce friction in debugging, improve communication across teams, and make systems slightly easier to reason about \u2014 without sacrificing compatibility or safety.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This page walks through the core workflow of TypeID: generating identifiers, inspecting them, and understanding how they fit into a real system.</p> <p>It is intentionally short. The goal is to get you productive quickly, not to explain every detail.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Install the package using your preferred tool.</p> <p>With pip:</p> <pre><code>pip install typeid-python\n</code></pre> <p>With uv:</p> <pre><code>uv add typeid-python\n</code></pre> <p>If you plan to use YAML schemas later, install the optional extra:</p> <pre><code>pip install \"typeid-python[yaml]\"\n</code></pre> <p>JSON schemas work without any extras.</p>"},{"location":"quickstart/#creating-a-typeid","title":"Creating a TypeID","text":"<p>A TypeID is created by providing a prefix that describes what the identifier represents.</p> <pre><code>from typeid import TypeID\n\ntid = TypeID(\"user\")\n\nvalue = str(tid)\n\nassert value.startswith(\"user_\")\nassert len(value.split(\"_\", 1)[1]) &gt; 0\n</code></pre> <p>This produces a string similar to:</p> <pre><code>user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>The prefix is meaningful to humans. The suffix is globally unique and time-sortable.</p> <p>Prefixes are optional. If you omit it, you get a prefix-less identifier:</p> <pre><code>from typeid import TypeID\n\ntid = TypeID(None)\n\nassert not tid.prefix\n</code></pre> <p>This can be useful when the type is implied by context or stored elsewhere.</p>"},{"location":"quickstart/#pre-defined-prefixes","title":"Pre-defined prefixes","text":"<p>Sometimes it's useful to have pre-defined prefix.</p> <pre><code>from dataclasses import dataclass, field\nfrom typing import Literal\nfrom typeid import TypeID, typeid_factory\n\nUserID = TypeID[Literal[\"user\"]]\ngen_user_id = typeid_factory(\"user\")\n\n\n@dataclass()\nclass UserDTO:\n    user_id: UserID = field(default_factory=gen_user_id)\n    full_name: str = \"A J\"\n    age: int = 18\n\n\nuser = UserDTO()\nassert str(user.user_id).startswith(\"user_\")\n</code></pre>"},{"location":"quickstart/#parsing-and-validation","title":"Parsing and validation","text":"<p>TypeIDs can be parsed back from strings.</p> <pre><code>from typeid import TypeID\n\nprefix = \"user\"\nsuffix = \"01h45ytscbebyvny4gc8cr8ma2\"\ntid = TypeID.from_string(f\"{prefix}_{suffix}\")\n\nassert tid.prefix == \"user\" and tid.suffix == suffix\n</code></pre> <p>If the string is invalid, parsing fails explicitly. Invalid identifiers are never silently accepted.</p> <p>When dealing with untrusted input, you will usually want to rely on the <code>explain</code> functionality instead of raising exceptions. This is covered later.</p>"},{"location":"quickstart/#uuid-compatibility","title":"UUID compatibility","text":"<p>Every TypeID is backed by a UUID.</p> <p>You can always extract the UUID:</p> <pre><code>tid.uuid\n</code></pre> <p>And you can always reconstruct a TypeID from a UUID:</p> <pre><code>from uuid6 import uuid7\nfrom typeid import TypeID\n\nu = uuid7()\ntid = TypeID.from_uuid(suffix=u, prefix=\"user\")\nassert str(tid).startswith(\"user_\")\n</code></pre> <p>This is the intended storage model:</p> <p>Store UUIDs in the database. Expose TypeIDs at the application boundary.</p> <p>You get the benefits of UUIDs at rest and the benefits of TypeIDs everywhere else.</p>"},{"location":"quickstart/#using-the-cli","title":"Using the CLI","text":"<p>TypeID also ships with a command-line interface.</p> <p>If you installed the CLI extra:</p> <pre><code>pip install \"typeid-python[cli]\"\n</code></pre> <p>You can generate identifiers directly:</p> <pre><code>typeid new -p user\n</code></pre> <p>You can inspect existing identifiers:</p> <pre><code>typeid decode user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>And you can convert between UUIDs and TypeIDs:</p> <pre><code>typeid encode &lt;uuid&gt; --prefix user\n</code></pre>"},{"location":"quickstart/#explaining-an-identifier","title":"Explaining an identifier","text":"<p>The most distinctive feature of this implementation is the ability to explain identifiers.</p> <pre><code>typeid explain user_01h45ytscbebyvny4gc8cr8ma2\n</code></pre> <p>This command inspects the identifier and reports:</p> <ul> <li>whether it is valid</li> <li>what prefix it uses</li> <li>which UUID it represents</li> <li>when it was created</li> </ul> <p>This works even without any configuration and never crashes on invalid input.</p>"},{"location":"quickstart/#what-to-read-next","title":"What to read next","text":"<p>If you want to understand why TypeID works the way it does, read Concepts.</p> <p>If you want to understand what explain can do, read Explain.</p> <p>If you want integration details or API reference material, those sections are available as well.</p> <p>At this point, you already know enough to start using TypeID in a real project.</p>"},{"location":"reference/cli/","title":"CLI","text":""},{"location":"reference/cli/#typeid.cli.decode","title":"<code>decode(encoded: str) -&gt; None</code>","text":"<p>Decode a TypeID into its components.</p> <p>This extracts: - the prefix (if any) - the underlying UUID</p> <p>This command is primarily intended for inspection and debugging.</p>"},{"location":"reference/cli/#typeid.cli.encode","title":"<code>encode(uuid: str, prefix: Optional[str] = None) -&gt; None</code>","text":"<p>Encode an existing UUID into a TypeID.</p> <p>This command is intended for cases where UUIDs already exist (e.g. stored in a database) and need to be represented as TypeIDs.</p>"},{"location":"reference/cli/#typeid.cli.explain","title":"<code>explain(encoded: str, schema_path: Optional[str], as_json: bool, no_schema: bool, no_links: bool) -&gt; None</code>","text":"<p>Explain a TypeID: parse/validate it, derive facts (uuid, created_at), and optionally enrich explanation from a user-provided schema.</p>"},{"location":"reference/cli/#typeid.cli.new","title":"<code>new(prefix: Optional[str] = None) -&gt; None</code>","text":"<p>Generate a new TypeID.</p> <p>If a prefix is provided, it will be validated and included in the output. If no prefix is provided, a prefix-less TypeID is generated.</p>"},{"location":"reference/explain/","title":"Explain","text":"<p>Explain subsystem for TypeID.</p> <p>This package provides a high-level, non-breaking API and CLI support for answering the question:</p> <pre><code>\"What is this TypeID?\"\n</code></pre> <p>It is intentionally: - additive (no changes to existing TypeID semantics), - schema-optional (works fully offline), - safe by default (read-only, no side effects).</p> Public API <p>explain(id_str, schema_path=None, **options) -&gt; Explanation</p>"},{"location":"reference/explain/#typeid.explain.Explanation","title":"<code>Explanation(id: str, valid: bool, parsed: ParsedTypeID, schema: Optional[TypeSchema] = None, derived: Dict[str, Any] = dict(), links: Dict[str, str] = dict(), provenance: Dict[str, Provenance] = dict(), warnings: List[str] = list(), errors: List[ParseError] = list())</code>  <code>dataclass</code>","text":"<p>Final explanation object produced by the explain engine.</p> <p>Sections: - parsed: always present (even if invalid; fields may be None) - schema: may be None if no schema found or schema loading disabled - derived: small dict for extra derived facts (extensible) - links: rendered links (from schema templates), safe for display - provenance: per-field provenance labels for transparency</p>"},{"location":"reference/explain/#typeid.explain.Explanation.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert to a JSON-serializable dict.</p> <p>We avoid serializing complex objects directly (datetime, Enums) without conversion to keep <code>--json</code> output stable and easy to consume.</p>"},{"location":"reference/explain/#typeid.explain.explain","title":"<code>explain(id_str: str, *, schema_path: Optional[str | Path] = None, enable_schema: bool = True, enable_links: bool = True) -&gt; Explanation</code>","text":"<p>High-level convenience API for explaining a TypeID.</p> <p>This function: - parses and validates the TypeID, - discovers and loads schema if enabled, - executes the explain engine, - never raises on normal user errors.</p> <p>Parameters:</p> Name Type Description Default <code>id_str</code> <code>str</code> <p>TypeID string to explain.</p> required <code>schema_path</code> <code>Optional[str | Path]</code> <p>Optional explicit path to schema file.          If None, discovery rules are applied.</p> <code>None</code> <code>enable_schema</code> <code>bool</code> <p>Disable schema usage entirely if False.</p> <code>True</code> <code>enable_links</code> <code>bool</code> <p>Disable link rendering if False.</p> <code>True</code> <p>Returns:</p> Type Description <code>Explanation</code> <p>Explanation object.</p>"},{"location":"reference/factory/","title":"Factory","text":""},{"location":"reference/factory/#typeid.factory.TypeIDFactory","title":"<code>TypeIDFactory(prefix: str)</code>  <code>dataclass</code>","text":"<p>Callable object that generates TypeIDs with a fixed prefix.</p> Example <p>user_id = TypeIDFactory(\"user\")()</p>"},{"location":"reference/factory/#typeid.factory.cached_typeid_factory","title":"<code>cached_typeid_factory(prefix: str) -&gt; Callable[[], TypeID]</code>  <code>cached</code>","text":"<p>Same as typeid_factory, but caches factories by prefix.</p> <p>Use this if you create factories repeatedly at runtime.</p>"},{"location":"reference/factory/#typeid.factory.typeid_factory","title":"<code>typeid_factory(prefix: str) -&gt; Callable[[], TypeID]</code>","text":"<p>Return a zero-argument callable that generates TypeIDs with a fixed prefix.</p> Example <p>user_id = typeid_factory(\"user\")()</p>"},{"location":"reference/typeid/","title":"TypeID","text":"<p>               Bases: <code>Generic[PrefixT]</code></p> <p>A TypeID is a human-meaningful, UUID-backed identifier.</p> <p>A TypeID is rendered as:</p> <pre><code>&lt;prefix&gt;_&lt;suffix&gt;   or just   &lt;suffix&gt;  (when prefix is None/empty)\n</code></pre> <ul> <li>prefix: optional semantic label (e.g. \"user\", \"order\"). It is not part of the UUID.   Prefixes are validated for allowed characters/shape (see <code>validate_prefix</code>).</li> <li>suffix: a compact, URL-safe Base32 encoding of a UUID (UUIDv7 by default).   Suffixes are validated structurally (see <code>validate_suffix</code>).</li> </ul> <p>Design notes: - A TypeID is intended to be safe to store as a string (e.g. in logs / URLs). - The underlying UUID can always be recovered via <code>.uuid</code>. - Ordering (<code>&gt;</code>, <code>&gt;=</code>) is based on lexicographic order of the string representation,   which corresponds to time-ordering if the UUID version is time-sortable (UUIDv7).</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>PrefixT</code> <p>a type-level constraint for the prefix (often <code>str</code> or a Literal).</p> required <p>Create a new TypeID.</p> <p>If <code>suffix</code> is not provided, a new UUIDv7 is generated and encoded as Base32. If <code>prefix</code> is provided, it is validated.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>Optional[PrefixT]</code> <p>Optional prefix. If None, the TypeID has no prefix and its string form will be just the suffix. If provided, it must pass <code>validate_prefix</code>.</p> <code>None</code> <code>suffix</code> <code>Optional[str]</code> <p>Optional Base32-encoded UUID string. If None, a new UUIDv7 is generated.</p> <code>None</code> <p>Raises:</p> Type Description <code>InvalidTypeIDStringException (or another project-specific exception)</code> <p>If <code>suffix</code> is invalid, or if <code>prefix</code> is invalid.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.prefix","title":"<code>prefix: str</code>  <code>property</code>","text":"<p>The prefix portion of the TypeID, as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The configured prefix, or \"\" if the TypeID is prefix-less.</p> Notes <ul> <li>Empty string is the presentation of \"no prefix\". Internally, <code>_prefix</code>   remains Optional to preserve the distinction between None and a real value.</li> </ul>"},{"location":"reference/typeid/#typeid.typeid.TypeID.suffix","title":"<code>suffix: str</code>  <code>property</code>","text":"<p>The Base32-encoded UUID portion of the TypeID (always present).</p> Notes <ul> <li>This is the identity-carrying part.</li> <li>It is validated at construction time.</li> </ul>"},{"location":"reference/typeid/#typeid.typeid.TypeID.uuid","title":"<code>uuid: uuid6.UUID</code>  <code>property</code>","text":"<p>The UUID represented by this TypeID.</p> <p>Returns:</p> Type Description <code>UUID</code> <p>The decoded UUID value.</p> Notes <ul> <li>This decodes <code>self.suffix</code> each time it is accessed.</li> <li>The UUID type here follows <code>uuid6.UUID</code> used by the project.</li> </ul>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__eq__","title":"<code>__eq__(value: object) -&gt; bool</code>","text":"<p>Equality based on prefix and suffix.</p> Notes <ul> <li>Two TypeIDs are considered equal if both their string components match.</li> <li>This is stricter than \"same UUID\" because prefix is part of the public ID.</li> </ul>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__ge__","title":"<code>__ge__(other) -&gt; bool</code>","text":"<p>Compare TypeIDs by lexicographic order of their string form (&gt;=).</p> <p>See <code>__gt__</code> for rationale and notes.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__gt__","title":"<code>__gt__(other) -&gt; bool</code>","text":"<p>Compare TypeIDs by lexicographic order of their string form.</p> <p>This is useful because TypeID suffixes based on UUIDv7 are time-sortable, so string order typically corresponds to creation time order (within a prefix).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True/False if <code>other</code> is a TypeID, otherwise NotImplemented.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Hash based on (prefix, suffix), allowing TypeIDs to be used as dict keys / set members.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__repr__","title":"<code>__repr__()</code>","text":"<p>Developer-friendly representation.</p> <p>Uses a constructor-like form to make debugging and copy/paste easier.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Render the TypeID into its canonical string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>\"_\" if prefix is present, otherwise \"\"."},{"location":"reference/typeid/#typeid.typeid.TypeID.from_string","title":"<code>from_string(string: str) -&gt; TypeID</code>  <code>classmethod</code>","text":"<p>Parse a TypeID from its string form.</p> <p>The input can be either: - \"_\" - \"\" (prefix-less) <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String representation of a TypeID.</p> required <p>Returns:</p> Type Description <code>TypeID</code> <p>A <code>TypeID</code> instance.</p> <p>Raises:</p> Type Description <code>InvalidTypeIDStringException (or another project-specific exception)</code> <p>If the string cannot be split/parsed or if the extracted parts are invalid.</p>"},{"location":"reference/typeid/#typeid.typeid.TypeID.from_uuid","title":"<code>from_uuid(suffix: uuid.UUID, prefix: Optional[PrefixT] = None) -&gt; TypeID</code>  <code>classmethod</code>","text":"<p>Construct a TypeID from an existing UUID.</p> <p>This is useful when you store UUIDs in a database but want to expose TypeIDs at the application boundary.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>UUID</code> <p>UUID value to encode into the TypeID suffix.</p> required <code>prefix</code> <code>Optional[PrefixT]</code> <p>Optional prefix to attach (validated if provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>TypeID</code> <p>A <code>TypeID</code> whose <code>.uuid</code> equals the provided UUID.</p>"}]}